#!/usr/bin/python

import os
import re
import sys
import hashlib

from libutils import *
from config import *
from calls import *
from errors import *

from libzip import extractArchive
from signatures import check_trick_from_file, DETECTION_TRICKS, DEBUGGING_TRICKS

def execute_command(command):
	p = os.popen(command)
	return p.readlines()

def timeout_command(command, timeout):
	import subprocess, datetime, os, time, signal
	cmd = command.split(" ")
	start = datetime.datetime.now()
	process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	while process.poll() is None:
		time.sleep(0.2)
		now = datetime.datetime.now()
		if (now - start).seconds> timeout:
			showWarning("Killing process %d" % process.pid)
			os.kill(process.pid, signal.SIGKILL)
			os.waitpid(-1, os.WNOHANG)
			return None
		return process.stdout.readlines()
		return process.stdout.read()

def executeMalware(malware, dirName, timeout, memory):
	# Bug fix
	# Kill Xvfb
	execute_command(KILL_XVFB_PATH)

	return timeout_command("%s %s %d %s %d" % (LAUNCHER_PATH, malware, (timeout - memory - 5), dirName, memory), timeout)

def analyzeMalware(sample, timeout, memory, version, subsample):
	
	data = sample.file.read()
	fileSize = len(data)
	
	if fileSize < MIN_SIZE:
		dieError("File size is too small!")
	if fileSize > MAX_SIZE:
		dieError("File size is too big!")
	
	try:
		subdata = subsample.file.read()
	except:
		pass
	
	hashes = generateHash(data)
	hashMD5, hashSHA1, hashSHA224, hashSHA256, hashSHA384, hashSHA512 = hashes
	
	# Select hash function
	hash = hashSHA512
	
	dirName = SAMPLE_DIR + os.sep + hash
		
	# Bug fix
	# Needed with Boa web server
	os.umask(DEFAULT_UMASK)
	if os.path.exists(dirName) == 1:
		showWarning("Folder already exists! File was previously analyzed?")
	else:
		os.mkdir(dirName)
		makeSymlink(dirName, hashMD5, hashSHA1, hashSHA224, hashSHA256, hashSHA384)
	
	try:
	  cleanfileName = cleanFile(sample.filename,data)
	except:
	  cleanfileName = "malware.exe"
	fileName = dirName + os.sep + cleanfileName
	
	try:
		f = file(fileName, "wb")
		f.write(data)
		f.close()
	except:
		dieError("Error saving file (%s)" % str(sys.exc_info()[1]))
	
	subfileName = dirName + os.sep + "additionalfiles.zip"
	
	try:
		f = file(subfileName, "wb")
		f.write(subdata)
		f.close()
	except:
		pass
	
	## If you change this function's return value, you must change here. (Static analysis)
	onlyStaticAnalysis = " ", hash, fileName, " ", hashes, " ", " ", fileSize
	##
	
	if timeout == 0:
		showWarning("Static analysis only!")
		showWarning("Dynamic analyzer disabled.")
		return onlyStaticAnalysis
	
	if getHeadersIfApply(fileName, justCheck=True) == "Not an Windows Executable":
		showWarning("Static analysis only!")
		showWarning("Not an Windows Executable.")
		return onlyStaticAnalysis
	
	lockName = SAMPLE_DIR + os.sep + "locked"
	
	if os.path.exists(lockName) == 1:
		showWarning("Static analysis only!")
		showWarning("Dynamic analyzer is busy at the moment. Please try again later.")
		return onlyStaticAnalysis
	else:
		lockAnalyze(lockName)
	
	execute_command(PREPARE_PATH + (" %s" % WINE_DIR))
	setVersion(version)
	
	execfileName = execFile(sample.filename)
	execName = EXEC_DIR + os.sep + execfileName
	
	try:
		f = file(execName, "wb")
		f.write(data)
		f.close()
	except:
		dieError("Error saving file (%s)" % str(sys.exc_info()[1]))
	
	try:
		extractArchive(subfileName, EXEC_DIR)
	except:
#		showWarning("Error saving file (%s)" % str(sys.exc_info()[1]))
		pass
	
	try:
		buf = executeMalware(execName, dirName + os.sep + "dump", timeout, memory)
	except:
		showWarning("Error running malware!")
		if isCgiMode():
			print "<br />"
		dieError(str(sys.exc_info()[1]))
	
	diff = diffFile(dirName)
	
	unlockAnalyze(lockName)
	
	error, errorMsg = checkRuntimeErrors(buf)
	
	if error == True:
		showWarning("One or more spawned processes crashed while running!")
	
	return buf, hash, fileName, execfileName, hashes, errorMsg, diff, fileSize

def getStrings(fileName):
	return execute_command(STRINGS_PATH + " %s %s" % (STRINGS_OPTION, fileName))

def getSignatureFromPEiD(pe):
	try:
		import peutils
		signatures = peutils.SignatureDatabase(PE_SIGNATURE_PATH)
		return signatures.match_all(pe)
	except:
		return None

def getSignatureFromTrID(fileName):
	try:
		msg = execute_command(TRID_PATH + (" %s " % fileName) + ("-d:%s" % TRID_SIGNATURE_PATH))
		
		idx = -1
		for line in msg:
			idx += 1
			if line.find("Collecting data from file:") > -1:
				idx += 1
				break
		
		return "".join(msg[idx:])
	except:
		return None

def getHeaders(fileName):
	msg = ""
	TrIDSig = getSignatureFromTrID(fileName)
	
	if TrIDSig:
		msg += "----------TrID Signatures----------\n\n"
		msg += "%s" % TrIDSig
	
	try:
		import pefile
		
		pe = pefile.PE(fileName)
		PEiDSig = getSignatureFromPEiD(pe)
		peInfo = pe.dump_info()
		
		if PEiDSig:
			msg += "----------PEiD Signatures----------\n\n"
			for match in PEiDSig:
				msg += "%s\n" % str(match[0])
			msg += "\n"
		
		msg += "".join(peInfo)
		return msg
	except:
#		return "Error getting headers: %s" % str(sys.exc_info()[1])
		return msg

def getHeadersIfApply(fileName, justCheck=False):
	f = file(fileName, "rb")
	buf = f.read(2)
	f.close()
	
	if buf == "MZ":
		if justCheck == False:
			return getHeaders(fileName)
		else:
			return " "
	else:
		return "Not an Windows Executable"

def junkCall(line):
	for junk in JUNK_CALLS:
		if re.search(junk, line, re.IGNORECASE):
			return True
	return False

def analyzeCalls(lines):
	prevLines = []
	for line in lines:
		for mcall in INTERESTING_CALLS:
			if re.search(mcall, line):
				if line not in prevLines and not junkCall(line):
					prevLines.append(line + "\t" + INTERESTING_CALLS[mcall])
	return prevLines

def showDumps(dirName, printHTML=True):
	dumps = os.listdir(dirName)
	dumps.sort()

	i = 0
	for dump in dumps:
		if dump.startswith("dump"): # "dump*" file only
			fileName = dirName + os.sep + dump
			
			if os.path.getsize(fileName) == 0:
				os.remove(fileName) # Remove file
				continue # Ignored dumped files with size 0
			
			i += 1
			
			if printHTML == True:
				headers = getHeadersIfApply(fileName)
				divHeaders = """divHeaders%d""" % i
				divDump = """divDump%d""" % i
				
				if dump == TCPDUMP_FILENAME:
					print """<a href="javascript:toggleShowHide('%s')"><img src="/img/headers.png" height="16" width="16"> Packet details</a>&nbsp;""" % (divDump)
					# dirName.split(os.sep)[-1] = hash
					print "<a href='/cgi-bin/download.py?hash=%s&amp;dump=%s'>%s</a>&nbsp;" % (cgi.escape(dirName.split(os.sep)[-1]), cgi.escape(dump), cgi.escape(dump))
					print "<br />"
					
					printBodyDiv(divDump, "".join(getNetworkDump(fileName)))
				else:
					print """<a href="javascript:toggleShowHide('%s')"><img src="/img/headers.png" height="16" width="16"> File headers</a>&nbsp;""" % (divHeaders)
					print """<a href="javascript:toggleShowHide('%s')"><img src="/img/strings.png" height="16" width="16"> File strings</a>&nbsp;""" % (divDump)
					# dirName.split(os.sep)[-1] = hash
					print "<a href='/cgi-bin/download.py?hash=%s&amp;dump=%s'>%s</a>&nbsp;" % (cgi.escape(dirName.split(os.sep)[-1]), cgi.escape(dump), cgi.escape(dump))
					print "<br />"
					
					# File headers
					printBodyDiv(divHeaders, headers)
					
					# File strings
					printBodyDiv(divDump, "".join(getStrings(fileName)))

	if i == 0:
		if printHTML == True:
			print "<i>No dumps</i><br />"

def showVMDetectionTricks(fileName, dirName, printHTML=True):
	dumps = os.listdir(dirName)
	dumps.sort()

	i = 0
	checkTricks = []

	for dump in dumps:
		fileName = dirName + os.sep + dump
		try:
			tricks = check_trick_from_file(fileName)
		except:
			pass
		
		if len(tricks) > 0:
			for trick in tricks:
				i += 1
				if printHTML == True:
					print "<b>Detected trick %s (%s)</b><br />" % (trick, repr(DETECTION_TRICKS[trick]))
				checkTricks.append(trick)
#				checkTricks.append(trick + "\t" + repr(DETECTION_TRICKS[trick]))

	if i == 0:
		if printHTML == True:
			print "<i>No known detection tricks found</i><br />"
	
	return checkTricks

def showDebuggingTricks(msg, printHTML=True):
	i = 0
	checkTricks = []

	for line in msg:
		for trick in DEBUGGING_TRICKS:
			if line.lower().find(trick.replace("%", "\\").lower()) > -1:
				if not trick in checkTricks:
					i += 1
					if printHTML == True:
						print """<b>Detected trick %s (%s)</b><br />""" % (trick, DEBUGGING_TRICKS[trick])
					checkTricks.append(trick)
					checkTricks.append(line)

	if i == 0:
		if printHTML == True:
			print "<i>No known detection tricks found</i><br />"
	
	return checkTricks

def checkRuntimeErrors(buf, printHTML=True):
	error = False
	errorMsg = []

	for line in buf:
		for err in RUNTIME_ERRORS:
			if line.find(err) > -1:
				error = True
				if not err in errorMsg:
					if printHTML == True:
						showWarning(RUNTIME_ERRORS[err])
					errorMsg.append(line)
	
	return error, errorMsg

def generateHash(data):
	temp = hashlib.md5()
	temp.update(data)
	hashMD5 = temp.hexdigest()
	
	temp = hashlib.sha1()
	temp.update(data)
	hashSHA1 = temp.hexdigest()
	
	temp = hashlib.sha224()
	temp.update(data)
	hashSHA224 = temp.hexdigest()
	
	temp = hashlib.sha256()
	temp.update(data)
	hashSHA256 = temp.hexdigest()
	
	temp = hashlib.sha384()
	temp.update(data)
	hashSHA384 = temp.hexdigest()
	
	temp = hashlib.sha512()
	temp.update(data)
	hashSHA512 = temp.hexdigest()
	
	return hashMD5, hashSHA1, hashSHA224, hashSHA256, hashSHA384, hashSHA512
	
def saveAsFile(data, dirName, fileName):
	fileName = dirName + os.sep + fileName
	try:
		f = file(fileName, "w")
		f.write(data)
		f.close()
	except:
		print "Error saving file (%s)" % (str(sys.exc_info()[1]))
		return " "
	
def readFile(dirName, fileName):
	fileName = dirName + os.sep + fileName
	try:
		f = file(fileName, "r")
		data = f.read()
		f.close()
		return data
	except:
		print "Error reading file (%s)" % (str(sys.exc_info()[1]))
		return " "
	
def makeSymlink(dirName, hashMD5, hashSHA1, hashSHA224, hashSHA256, hashSHA384):
	symlinkMD5 = SAMPLE_DIR + os.sep + hashMD5
	symlinkSHA1 = SAMPLE_DIR + os.sep + hashSHA1
	symlinkSHA224 = SAMPLE_DIR + os.sep + hashSHA224
	symlinkSHA256 = SAMPLE_DIR + os.sep + hashSHA256
	symlinkSHA384 = SAMPLE_DIR + os.sep + hashSHA384
	
	os.symlink(dirName, symlinkMD5)
	os.symlink(dirName, symlinkSHA1)
	os.symlink(dirName, symlinkSHA224)
	os.symlink(dirName, symlinkSHA256)
	os.symlink(dirName, symlinkSHA384)
	
def setVersion(version):
	fileName = WINE_DIR + os.sep + "user.reg"
	data = """
[Software\\\\Wine]
"Version"="%s"
""" % (version)
	try:
		f = file(fileName, "a")
		f.write(data)
		f.close()
	except:
		showWarning("Unable to set Windows version!")

def unpackFile(msg, fileName):
	if msg.find("UPX") > -1:
		execute_command(UPX_PATH + (" -dk %s" % fileName))
	if msg.find("(.PDF)") > -1:
		import shutil
		backupFileName = fileName + ".pdf.orig"
		shutil.copy(fileName, backupFileName)
		execute_command(PDFTK_PATH + " %s output %s uncompress" % (backupFileName, fileName))
		if os.path.getsize(fileName) == 0:
			shutil.move(backupFileName, fileName)

def pdftk_dump_data(msg, fileName):
    if msg.find("(.PDF)") > -1:
        return "".join(execute_command(PDFTK_PATH + " %s dump_data" % (fileName)))

def pdfid(msg, fileName):
    if msg.find("(.PDF)") > -1:
        import pdfid
        return pdfid.PDFiD2String(pdfid.PDFiD(fileName), False)

def pdfparser_a(msg, fileName):
    if msg.find("(.PDF)") > -1:
        import pdf_parser as pdfparser
        # This entire code block is heavily based on the
        # Main() function in Didier Steven's pdf-parser.py
        oPDFParser = pdfparser.cPDFParser(fileName)
        cntComment = 0
        cntXref = 0
        cntTrailer = 0
        cntStartXref = 0
        cntIndirectObject = 0
        dicObjectTypes = {}

        while True:
            object = oPDFParser.GetObject()
            if object != None:
                if object.type == pdfparser.PDF_ELEMENT_COMMENT:
                    cntComment += 1
                elif object.type == pdfparser.PDF_ELEMENT_XREF:
                    cntXref += 1        
                elif object.type == pdfparser.PDF_ELEMENT_TRAILER:
                    cntTrailer += 1     
                elif object.type == pdfparser.PDF_ELEMENT_STARTXREF:
                    cntStartXref += 1   
                elif object.type == pdfparser.PDF_ELEMENT_INDIRECT_OBJECT:
                    cntIndirectObject += 1
                    type = object.GetType()
                    if not type in dicObjectTypes:
                        dicObjectTypes[type] = [object.id]
                    else:               
                        dicObjectTypes[type].append(object.id)
            else:       
                break           
        retval = 'Comment: %s\nXREF: %s\nTrailer: %s\nStartXref: %s\nIndirect object: %s\n' % (cntComment, cntXref, cntTrailer, cntStartXref, cntIndirectObject)
        names = dicObjectTypes.keys()
        names.sort()
        for key in names:
            retval += ' %s %d: %s\n' % (key, len(dicObjectTypes[key]), ', '.join(map(lambda x: '%d' % x, dicObjectTypes[key])))
        return retval


def diffFile(dirName):
	diffName = dirName + os.sep + "diff"
	
	try:
		os.mkdir(diffName)
	except:
		pass
	
	execute_command(PREPARE_PATH + (" %s" % WINE_BACKUP_DIR))
	
	dirDiff = execute_command(DIFF_PATH + (" %s %s %s" % (WINE_BACKUP_DIR, WINE_DIR, diffName)))
	
	return dirDiff

def lockAnalyze(lockName):
	try:
		os.mkdir(lockName)
	except:
		dieError("Failed to lock!")

def unlockAnalyze(lockName):
	try:
		os.rmdir(lockName)
	except:
		dieError("Failed to unlock!")

def getNetworkDump(fileName):
	dump = execute_command(TCPDUMP_PATH + (" %s -r %s" % (TCPDUMP_OPTION_READ, fileName)))
	
	return dump

def getPdfJavaScript(strings, checkHeader=False, temp=" "):
	try:
		if checkHeader == False:
			pdfStart = False
			idx = -1
			idxLimit = 3
		
			# Try to find PDF header (%PDF-)

			for line in strings:
				idx += 1
				if idx == idxLimit:
					break
				if line.find("PDF") > -1:
					pdfStart = True
					break
		
			if pdfStart == False:
				return temp
		
		pdfJavaScriptStart = False
		pdfJavaScriptEnd = False
		idxStart = -1
		idxEnd = -1
		
		# Try to find PDF JavaScript (stream)
		
		for lineStart in strings:
			idxStart += 1
			try:
				# Fixme: False positive
				if lineStart.startswith("/S ") and strings[idxStart + 4].startswith("stream") and (strings[idxStart + 5].find(";") > -1 or strings[idxStart + 5].find("{") > -1 or strings[idxStart + 5].lstrip().startswith("function") or strings[idxStart + 5].lstrip().startswith("//")):
					idxStart += 5
					pdfJavaScriptStart = True
					break
				if lineStart.startswith("/Length") and strings[idxStart + 1].startswith("stream") and (strings[idxStart + 2].find(";") > -1 or strings[idxStart + 2].find("{") > -1 or strings[idxStart + 2].lstrip().startswith("function") or strings[idxStart + 2].lstrip().startswith("//")):
					idxStart += 2
					pdfJavaScriptStart = True
					break
			except:
				pass
		
		idxEnd = idxStart
		
		for lineEnd in strings[idxStart:]:
			if (lineEnd.find(";") > -1 or lineEnd.find("}") > -1 or lineEnd.find(")") > -1 or lineEnd.lstrip().startswith("//")) and strings[idxEnd + 1].startswith("endstream"):
				idxEnd += 1
				pdfJavaScriptEnd = True
				break
			idxEnd += 1
		
#		print pdfJavaScriptStart, pdfJavaScriptEnd
		
		if pdfJavaScriptStart == True and pdfJavaScriptEnd == True:
			# Check false positive
			pdfJavaScript = True
			
			for line in strings[idxStart:idxEnd]:
				if line.startswith("endstream"):
					pdfJavaScript = False
					break
					
			if pdfJavaScript == True:
				return "".join(strings[idxStart:idxEnd]) + "\n" + getPdfJavaScript(strings[idxEnd:], True)
			else:
				return temp
		else:
			# If failed, try to find PDF JavaScript (/JS)
			pdfJavaScriptStart = False
			pdfJavaScriptEnd = False
			idxStart = -1
			idxEnd = -1
			
			for line in strings:
				idxStart += 1
				if line.startswith("/JS "):
					pdfJavaScriptStart = True
					break
			
			idxEnd = idxStart
			
			for line in strings[idxStart:]:
				idxEnd += 1
				if line.startswith("/Type "):
					idxEnd -= 1
					pdfJavaScriptEnd = True
					break
				if line.startswith("/S "):
					idxEnd -= 1
					pdfJavaScriptEnd = True
					break
				if line.startswith("endobj"):
					idxEnd -= 1
					pdfJavaScriptEnd = True
					break
			
			if pdfJavaScriptStart == True and pdfJavaScriptEnd == True:
				return "".join(strings[idxStart:idxEnd]) + "\n" + getPdfJavaScript(strings[idxEnd:], True)
			else:
				# If all attempt failed, try to find PDF OpenAction
				pdfOpenAction = False
				idx = -1
				
				for line in strings:
					idx += 1
					if line.find("/OpenAction ") > -1:
						pdfOpenAction = True
						break
				
				if pdfOpenAction == True:
					msg = "/* Warning: PDF OpenAction detected.\n%s */" % strings[idx]
					return msg
				else:
					return temp
	except:
		print "Nooo!"
		print str(sys.exc_info()[1])
		return temp

def getPdfAnalysis(headers, fileName):
	# PDF Analysis
	pdfAnalysis = ""
	try:
		output_pdftk = pdftk_dump_data(headers, fileName)
		if len(output_pdftk) > 0:
			pdfAnalysis += "===== PDFTK dump_data =====\n%s\n\n" % (output_pdftk)
		output_pdfid = pdfid(headers, fileName)
		if len(output_pdfid) > 0:
			pdfAnalysis += "===== PDFID =====\n%s\n\n" % (output_pdfid)
		output_pdfparser = pdfparser_a(headers, fileName)
		if len(output_pdfparser) > 0:
			pdfAnalysis += "===== PDFPARSER -a =====\n%s\n\n" % (output_pdfparser)
	except:
		pass
		
	return pdfAnalysis
